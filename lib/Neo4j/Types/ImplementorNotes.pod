# PODNAME: Neo4j::Types::ImplementorNotes
# ABSTRACT: Guidance for driver implementors

=encoding UTF-8

=head1 OVERVIEW

When writing a Neo4j driver in Perl, you'll need to consider how to
match Cypher types to Perl types and vice versa. This document tries
to give implementation advice for each Cypher type.

Some Cypher types are fairly generic and seemingly straightforward to
map to Perl. However, there are some pitfalls, which are discussed
below. Other types (such as Neo4j nodes) are more specialised,
requiring a custom Perl data structure. The L<Neo4j::Types>
distribution defines roles (interfaces with method behaviours)
that may be performed by such data structures.

B<You probably don't need to read this document,> unless you happen
to be writing a Neo4j driver or other software that performs the
L<Neo4j::Types> roles or inherits from these modules.

=head1 STRUCTURAL TYPES

Neo4j structural types are nodes, relationships, paths.
They may be represented as:

=over

=item * L<Neo4j::Types::Node>

=item * L<Neo4j::Types::Relationship>

=item * L<Neo4j::Types::Path>

=back

These modules should be treated as roles. A role defines an
object-oriented interface with specific behaviour for others
to implement.

While these modules currently offer default implementations of
all methods, it is strongly recommended for implementors to
write their own method implementations for their own data
structures in order to maintain encapsulation and to reduce
the risk of action at a distance.

The methods defined by this distribution are loosely modelled
on the Neo4j Driver API. They don't match that API precisely
because the official Neo4j drivers don't always use the exact
same method names for their functionality, and the
L<Neo4j Driver API Spec|https://neo4j.com/docs/bolt/current/driver-api/>
currently doesn't discuss these methods.

=head2 Node

See L<Neo4j::Types::Node> for the methods defined by that role.

The recommended way to have your own module perform the role
is to write implementations for all the methods, then declare
L<Neo4j::Types::Node> as a parent type.

 package Local::Node;
 use parent 'Neo4j::Types::Node';
 
 sub get        ($self, $property_key) {...}
 sub properties ($self) {...}
 
 sub labels     ($self) {...}
 
 sub id         ($self) {...}

You are free in your choice of the internal data structure.
While L<Neo4j::Types::Node> currently provides default
implementations of all methods, these only exist because some
versions of L<Neo4j::Bolt::Node> might expect them.
They may be removed in future and should not be relied upon.

It is recommended that the C<id()> method returns a number for
which L<builtin/"created_as_number"> would be truthy (S<e. g.>
C<0 + $id>). This can make roundtrips easier.

The C<labels()> and C<properties()> methods must not return
C<undef>. If there are no labels or properties, an empty list
or an empty hash reference must be returned.
(The default implementations of methods in L<Neo4j::Types::Node>
currently also handle C<undef> in the data structure for bug
compatibility with L<Neo4j::Bolt::CTypeHandlers>, but this may
change in future.)

Trying to access a property that doesn't exist must yield the
scalar value C<undef>, both for the C<get()> method as well as
the hash reference returned by C<properties()>. Expect users who
wish to determine whether a particular property key does in fact
not exist or whether it simply has the value C<undef> to use
the idiom C<< exists $node->properties->{$key} >>.

=head2 Relationship

See L<Neo4j::Types::Relationship> for the methods defined
by that role.

The recommended way to have your own module perform the role
is to write implementations for all the methods, then declare
L<Neo4j::Types::Relationship> as a parent type.

 package Local::Relationship;
 use parent 'Neo4j::Types::Relationship';
 
 sub get        ($self, $property_key) {...}
 sub properties ($self) {...}
 
 sub type       ($self) {...}
 
 sub id         ($self) {...}
 sub start_id   ($self) {...}
 sub end_id     ($self) {...}

You are free in your choice of the internal data structure.
While L<Neo4j::Types::Relationship> currently provides default
implementations of all methods, these only exist because some
versions of L<Neo4j::Bolt::Relationship> might expect them.
They may be removed in future and should not be relied upon.

It is recommended that the methods C<id()>, C<start_id()>,
and C<end_id()> return a number for which
L<builtin/"created_as_number"> would be truthy
(S<e. g.> C<0 + $id>). This can make roundtrips easier.

For the C<get()> and C<properties()> methods, the same
considerations as above for C<get()> and C<properties()>
on L<nodes|/"Node"> apply.

=head2 Path

See L<Neo4j::Types::Path> for the methods defined by that role.

The recommended way to have your own module perform the role
is to write implementations for all the methods, then declare
L<Neo4j::Types::Path> as a parent type.

 package Local::Path;
 use parent 'Neo4j::Types::Path';
 
 sub elements      ($self) {...}
 sub nodes         ($self) {...}
 sub relationships ($self) {...}

You are free in your choice of the internal data structure.
While L<Neo4j::Types::Path> currently provides default
implementations of all methods, these only exist because some
versions of L<Neo4j::Bolt::Path> might expect them.
They may be removed in future and should not be relied upon.

=head1 SCALAR TYPES

Values of the following types can in principle be stored as a Perl
scalar. However, Perl scalars by themselves cannot cleanly separate
between all of these types. This can make it difficult to convert
scalars back to Cypher types (for example for the use in Cypher
statements parameters).

=head2 Number (Integer or Float)

Both Neo4j and Perl internally distinguish between integer numbers
and floating-point numbers. Neo4j stores these as Java C<long> and
C<double>, which both are signed 64-bit types. In Perl, their
precision is whatever was used by the C compiler to build your
Perl executable (usually 64-bit types as well on modern systems).

Both Neo4j and Perl will automatically convert integers to floats
to calculate an expression if necessary (like for C<1 + 0.5>), so
the distinction between integers and floats often doesn't matter.
However, integers and floats are both just scalars in Perl, which
may make it difficult to create a float with an integer value in
Neo4j (for example, trying to store C<$a = 2.0 + 1> as a property
may result in the integer C<3> being stored in Neo4j).

L<perlnumber> explains further details on type conversions in Perl.
In particular, Perl will also try to automatically convert between
strings and numbers, but Neo4j will not. This may have unintended
consequences, as the following example demonstrates.

 $id = get_id_from_node($node);  # returns an integer
 say "The ID is $id.";           # silently turns $id into a string
 $node = get_node_by_id($id);    # fails: ID must be integer

This latter situation may be solved by using unary coercions.

 $string = "$number";
 $number = 0 + $string;

In the future, the L<Neo4j::Types> distribution might be extended
to offer ways to better handle the issues described in this section.

Note that while Neo4j easily handles the special floating point
values -0.0, NaN and Â±Infinity, Perl support for these values has
various issues (that may vary by platform). See L<Data::Float> for
details.

=head2 String

Perl scalars are a good match for Neo4j strings. However, in some
situations, scalar strings may easily be confused with numbers or
byte arrays in Perl.

Neo4j strings are always encoded in UTF-8. Perl supports this as
well, though string scalars that only contain ASCII are usually
not treated as UTF-8 internally for efficiency reasons.

=head2 Boolean

Perl only gained useful native boolean values
L<in version 5.35.4|perl5354delta/"Stable boolean tracking">.
On earlier versions, various CPAN modules attempt to solve
this problem, including L<boolean>, L<Types::Bool>, and
L<Types::Serialiser>. Among them, L<JSON::PP::Boolean> has
the advantage that it has long been in Perl CORE.

Some of the Perl JSON modules are currently (2023) in the
process of adding support for Perl native booleans. It may
be useful to wait until those L<builtin> functions that
provide access to Perl native booleans have left
L<experimental status|perlexperiment/"The builtin namespace">
and then follow whichever approach those other modules chose.

=head2 Null

The Cypher C<null> value can be neatly implemented as Perl C<undef>.

=head2 Byte array

Byte arrays are not actually Cypher types, but still have some
limited support as pass-through values in Neo4j. In Perl, byte
arrays are most efficiently represented as string scalars with
their C<UTF8> flag turned off (though there may be some gotchas;
see L<perlguts/"Working with SVs"> for details).

However, it usually isn't possible to determine whether such a
scalar actually is supposed to be a byte array or a string; see
L<perlguts/"How can I recognise a UTF-8 string?">. In the future,
the L<Neo4j::Types> distribution might be extended to offer ways
to handle this.

=head1 SPATIAL TYPES

The only spatial type currently offered by Neo4j is the point.
It may be represented as L<Neo4j::Types::Point>.

It might be possible to (crudely) represent other spatial types by
using a list of points plus external metadata, or in a Neo4j graph
by treating the graph itself as a spatial representation.

The coordinate reference systems of spatial points in Neo4j are
currently severely constrained. There is no way to tag points with
the CRS they actually use, and for geographic coordinates (lat/lon),
only a single, subtly non-standard CRS is even supported. For uses
that don't require the spatial functions that Neo4j offers, it might
be best to eschew the point type completely and store coordinate
pairs as a simple list in the Neo4j database instead.

=head2 Point

See L<Neo4j::Types::Point> for the methods defined by that role.

The recommended way to have your own module perform the role
is to write implementations for all the methods, then declare
L<Neo4j::Types::Point> as a parent type.

 package Local::Point;
 use parent 'Neo4j::Types::Point';
 
 sub new         ($class, $neo4j_srid, @coordinates) {...}
 sub srid        ($self) {...}
 sub coordinates ($self) {...}
 
 sub X           ($self) {...}  # uppercase X
 sub longitude   ($self) {...}
 
 sub Y           ($self) {...}  # uppercase Y
 sub latitude    ($self) {...}
 
 sub Z           ($self) {...}  # uppercase Z
 sub height      ($self) {...}

You are free in the choice of your own module's internal
data structure. If you instead choose to use the generic
implementation provided by L<Neo4j::Types::Point> itself, you
should treat it as entirely opaque and should not access the
data structure in any other way than through the methods
specified in L<Neo4j::Types::Point>.

It is recommended that all methods return a number for which
L<builtin/"created_as_number"> would be truthy
(S<e. g.> C<0 + $srid>). This can make roundtrips easier.

=head1 TEMPORAL TYPES

Cypher temporal types include: Date, Time, LocalTime, DateTime,
LocalDateTime, and Duration.

This distribution currently does not handle dates, times, or
durations. It is suggested to use the existing packages L<DateTime>
and L<DateTime::Duration>.

=head1 LIST AND MAP

Constructed types, formerly known as composite types, are:

=over

=item * List

=item * Map (also known as Dictionary)

=back

In Perl, these types match simple unblessed array and hash
references very nicely.

=head1 SEE ALSO

=over

=item * L<Neo4j::Bolt/"Return Types">

=item * L<Neo4j::Driver::Record/"get">

=item * L<REST::Neo4p::Entity>

=item * L<"Values and types" in Neo4j Cypher Manual|https://neo4j.com/docs/cypher-manual/5/values-and-types/>

=back
